"""
Modern Session Authentication Handler for LearnTrac API
Replaces Cognito JWT authentication with modern session-based auth

This handler validates session tokens generated by the Trac Modern Auth plugin
and provides secure, modern authentication for the Python 3.11 API.
"""

import logging
import httpx
import hmac
import hashlib
import base64
import json
import time
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from fastapi import HTTPException, Request, Security
from fastapi.security import HTTPBearer
import asyncio

from ..config import settings

logger = logging.getLogger(__name__)

security = HTTPBearer(auto_error=False)


@dataclass
class AuthenticatedUser:
    """Represents an authenticated user from modern session"""
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    permissions: List[str] = None
    groups: List[str] = None
    session_id: str = ""
    is_authenticated: bool = True
    
    def __post_init__(self):
        if self.permissions is None:
            self.permissions = []
        if self.groups is None:
            self.groups = []
    
    @property
    def is_admin(self) -> bool:
        """Check if user is admin"""
        return 'TRAC_ADMIN' in self.permissions or 'admin' in self.groups
    
    @property
    def is_instructor(self) -> bool:
        """Check if user is instructor"""
        return any(perm in self.permissions for perm in [
            'LEARNING_INSTRUCT', 'TICKET_CREATE', 'WIKI_MODIFY'
        ]) or 'instructors' in self.groups
    
    @property
    def is_student(self) -> bool:
        """Check if user has student access"""
        return (
            'LEARNING_PARTICIPATE' in self.permissions or 
            'students' in self.groups or 
            self.is_authenticated
        )
    
    def has_permission(self, permission: str) -> bool:
        """Check if user has specific permission"""
        return permission in self.permissions
    
    def has_any_permission(self, permissions: List[str]) -> bool:
        """Check if user has any of the specified permissions"""
        return any(p in self.permissions for p in permissions)
    
    def has_all_permissions(self, permissions: List[str]) -> bool:
        """Check if user has all specified permissions"""
        return all(p in self.permissions for p in permissions)


class ModernSessionValidator:
    """Validates modern session tokens from Trac"""
    
    def __init__(self):
        # Get configuration from settings
        self.secret_key = getattr(settings, 'trac_auth_secret', '')
        self.trac_base_url = getattr(settings, 'trac_base_url', 'http://localhost:8000')
        self.redis_url = getattr(settings, 'redis_url', 'redis://localhost:6379')
        
        # Session cache for performance
        self.session_cache = {}
        self.cache_ttl = 300  # 5 minutes
        
        if not self.secret_key:
            logger.warning("trac_auth_secret not configured - token validation will fail")
    
    async def validate_request(self, request: Request) -> Optional[AuthenticatedUser]:
        """
        Validate authentication from request
        
        Checks multiple authentication methods:
        1. Modern session token in cookies
        2. API key in headers
        3. Basic auth for development
        """
        try:
            # Method 1: Modern session token
            session_token = self._extract_session_token(request)
            if session_token:
                user = await self._validate_session_token(session_token)
                if user:
                    return user
            
            # Method 2: API key authentication
            api_key = request.headers.get('X-API-Key')
            if api_key:
                user = await self._validate_api_key(api_key)
                if user:
                    return user
            
            # Method 3: Development mode basic auth
            if settings.environment == "development":
                basic_auth = request.headers.get('Authorization')
                if basic_auth and basic_auth.startswith('Basic '):
                    user = self._validate_basic_auth(basic_auth)
                    if user:
                        return user
            
            return None
            
        except Exception as e:
            logger.error(f"Authentication validation error: {e}")
            return None
    
    def _extract_session_token(self, request: Request) -> Optional[str]:
        """Extract session token from request"""
        # Try cookie first (standard Trac auth)
        session_token = request.cookies.get('trac_auth_token')
        if session_token:
            return session_token
        
        # Try Authorization header
        auth_header = request.headers.get('Authorization')
        if auth_header and auth_header.startswith('Bearer '):
            return auth_header[7:]  # Remove 'Bearer ' prefix
        
        # Try custom header
        return request.headers.get('X-Session-Token')
    
    async def _validate_session_token(self, session_token: str) -> Optional[AuthenticatedUser]:
        """Validate modern session token"""
        try:
            # Check cache first
            cache_key = f"session:{session_token[:20]}"
            if cache_key in self.session_cache:
                cached_data = self.session_cache[cache_key]
                if cached_data['expires'] > time.time():
                    return cached_data['user']
                else:
                    del self.session_cache[cache_key]
            
            # Verify token signature
            if not self._verify_token_signature(session_token):
                logger.warning("Invalid session token signature")
                return None
            
            # Extract and validate payload
            payload = self._extract_token_payload(session_token)
            if not payload:
                logger.warning("Could not extract token payload")
                return None
            
            # Check expiration
            if payload.get('expires_at', 0) < int(time.time()):
                logger.info("Session token has expired")
                return None
            
            # Validate session with Redis/storage
            if not await self._validate_session_storage(session_token, payload):
                logger.warning("Session not found in storage")
                return None
            
            # Create user object
            user = AuthenticatedUser(
                username=payload.get('user_id', ''),
                permissions=payload.get('permissions', []),
                groups=payload.get('groups', []),
                session_id=payload.get('session_id', ''),
                # These would be enriched from Trac if needed
                email=None,
                full_name=None
            )
            
            # Cache for performance
            self.session_cache[cache_key] = {
                'user': user,
                'expires': time.time() + self.cache_ttl
            }
            
            return user
            
        except Exception as e:
            logger.error(f"Session token validation error: {e}")
            return None
    
    def _verify_token_signature(self, session_token: str) -> bool:
        """Verify HMAC signature of session token"""
        try:
            if not self.secret_key:
                return False
            
            parts = session_token.split('.')
            if len(parts) != 2:
                return False
            
            payload_b64, signature = parts
            
            # Recalculate signature
            expected_signature = hmac.new(
                self.secret_key.encode('utf-8'),
                payload_b64.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            # Constant-time comparison
            return hmac.compare_digest(signature, expected_signature)
            
        except Exception as e:
            logger.error(f"Token signature verification failed: {e}")
            return False
    
    def _extract_token_payload(self, session_token: str) -> Optional[Dict[str, Any]]:
        """Extract payload from session token"""
        try:
            payload_b64 = session_token.split('.')[0]
            payload_json = base64.b64decode(payload_b64.encode('ascii')).decode('utf-8')
            return json.loads(payload_json)
        except Exception as e:
            logger.error(f"Failed to extract token payload: {e}")
            return None
    
    async def _validate_session_storage(self, session_token: str, payload: Dict[str, Any]) -> bool:
        """Validate session exists in Redis/storage"""
        try:
            # For now, we trust the token signature
            # In production, you might want to check Redis for session existence
            # This would require Redis connection from the API
            
            # TODO: Implement Redis validation if needed
            # session_key = f"trac_session:{hashlib.sha256(session_token.encode()).hexdigest()[:32]}"
            # return await redis_client.exists(session_key)
            
            return True
            
        except Exception as e:
            logger.error(f"Session storage validation error: {e}")
            return False
    
    async def _validate_api_key(self, api_key: str) -> Optional[AuthenticatedUser]:
        """Validate API key for service-to-service calls"""
        try:
            # Check against configured API keys
            valid_api_keys = getattr(settings, 'valid_api_keys', [])
            
            if api_key in valid_api_keys:
                return AuthenticatedUser(
                    username="api_service",
                    permissions=["TRAC_ADMIN", "API_ACCESS"],
                    groups=["api"],
                    session_id=f"api_{api_key[:8]}"
                )
            
            # Check if it's the internal service key
            internal_key = getattr(settings, 'internal_api_key', '')
            if internal_key and api_key == internal_key:
                return AuthenticatedUser(
                    username="internal_service",
                    permissions=["TRAC_ADMIN", "INTERNAL_API"],
                    groups=["internal"],
                    session_id=f"internal_{api_key[:8]}"
                )
            
            return None
            
        except Exception as e:
            logger.error(f"API key validation error: {e}")
            return None
    
    def _validate_basic_auth(self, basic_auth: str) -> Optional[AuthenticatedUser]:
        """Validate basic auth for development"""
        try:
            if settings.environment != "development":
                return None
            
            # Simple development authentication
            # In production, this should be disabled
            return AuthenticatedUser(
                username="dev_user",
                permissions=["LEARNING_PARTICIPATE", "TICKET_VIEW"],
                groups=["developers"],
                session_id="dev_session"
            )
            
        except Exception as e:
            logger.error(f"Basic auth validation error: {e}")
            return None


# Create singleton instance
session_validator = ModernSessionValidator()


async def get_current_user(request: Request) -> Optional[AuthenticatedUser]:
    """
    Get current authenticated user from request (optional)
    
    Returns None if not authenticated - does not raise exceptions
    
    Usage:
        @router.get("/optional-auth")
        async def optional_route(
            request: Request,
            user: Optional[AuthenticatedUser] = Depends(get_current_user)
        ):
            if user:
                return {"message": f"Hello {user.username}"}
            else:
                return {"message": "Hello anonymous"}
    """
    return await session_validator.validate_request(request)


async def get_current_user_required(request: Request) -> AuthenticatedUser:
    """
    Get current authenticated user (required - raises 401 if not authenticated)
    
    Usage:
        @router.get("/protected")
        async def protected_route(
            request: Request,
            user: AuthenticatedUser = Depends(get_current_user_required)
        ):
            return {"user": user.username}
    """
    user = await get_current_user(request)
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Authentication required. Please log in through Trac.",
            headers={"WWW-Authenticate": "Bearer"}
        )
    return user


def require_permissions(permissions: List[str], require_all: bool = True):
    """
    Dependency factory to require specific permissions
    
    Usage:
        @router.post("/admin-only")
        async def admin_route(
            request: Request,
            user: AuthenticatedUser = Depends(require_permissions(["TRAC_ADMIN"]))
        ):
            return {"message": "Admin access granted"}
    """
    async def permission_checker(request: Request) -> AuthenticatedUser:
        user = await get_current_user_required(request)
        
        if require_all:
            if not user.has_all_permissions(permissions):
                raise HTTPException(
                    status_code=403,
                    detail=f"Missing required permissions: {permissions}"
                )
        else:
            if not user.has_any_permission(permissions):
                raise HTTPException(
                    status_code=403,
                    detail=f"Missing any of required permissions: {permissions}"
                )
        return user
    
    return permission_checker


def require_roles(roles: List[str]):
    """
    Dependency factory to require specific roles
    
    Usage:
        @router.post("/instructor-only")
        async def instructor_route(
            request: Request,
            user: AuthenticatedUser = Depends(require_roles(["instructor", "admin"]))
        ):
            return {"message": "Instructor access granted"}
    """
    async def role_checker(request: Request) -> AuthenticatedUser:
        user = await get_current_user_required(request)
        
        # Check if user has any of the required roles
        has_role = False
        if "admin" in roles and user.is_admin:
            has_role = True
        elif "instructor" in roles and user.is_instructor:
            has_role = True
        elif "student" in roles and user.is_student:
            has_role = True
        
        # Also check groups directly
        if not has_role:
            has_role = any(role in user.groups for role in roles)
        
        if not has_role:
            raise HTTPException(
                status_code=403,
                detail=f"Access denied. Required roles: {roles}"
            )
        
        return user
    
    return role_checker


# Convenience dependencies
require_admin = require_roles(["admin"])
require_instructor = require_roles(["instructor", "admin"])
require_student = require_roles(["student", "instructor", "admin"])

# Permission-based dependencies
require_trac_admin = require_permissions(["TRAC_ADMIN"])
require_learning_access = require_permissions(
    ["LEARNING_PARTICIPATE", "LEARNING_INSTRUCT"], 
    require_all=False
)
require_ticket_access = require_permissions(
    ["TICKET_VIEW", "TICKET_CREATE"], 
    require_all=False
)


# CSRF Protection for state-changing requests
async def validate_csrf_token(request: Request, user: AuthenticatedUser) -> bool:
    """
    Validate CSRF token for state-changing requests
    
    This should be called for POST, PUT, DELETE, PATCH requests
    """
    if request.method not in ['POST', 'PUT', 'DELETE', 'PATCH']:
        return True  # No CSRF check needed for safe methods
    
    # Get CSRF token from header or form data
    csrf_token = request.headers.get('X-CSRF-Token')
    if not csrf_token:
        # Try to get from form data
        try:
            form_data = await request.form()
            csrf_token = form_data.get('csrf_token')
        except:
            pass
    
    if not csrf_token:
        raise HTTPException(
            status_code=403,
            detail="CSRF token required for this request"
        )
    
    # For now, we accept any non-empty CSRF token
    # In production, this should validate against the session
    return len(csrf_token) > 0


def require_csrf_protection():
    """
    Dependency to require CSRF protection for state-changing requests
    
    Usage:
        @router.post("/protected-action")
        async def protected_action(
            request: Request,
            user: AuthenticatedUser = Depends(get_current_user_required),
            csrf_valid: bool = Depends(require_csrf_protection())
        ):
            return {"message": "Action completed"}
    """
    async def csrf_checker(request: Request) -> bool:
        user = await get_current_user_required(request)
        return await validate_csrf_token(request, user)
    
    return csrf_checker